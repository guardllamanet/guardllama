// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: api/v1/api.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// WireGuardServiceClient is the client API for WireGuardService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WireGuardServiceClient interface {
	GetWireGuardDevice(ctx context.Context, in *GetWireGuardDeviceRequest, opts ...grpc.CallOption) (*GetWireGuardDeviceResponse, error)
}

type wireGuardServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWireGuardServiceClient(cc grpc.ClientConnInterface) WireGuardServiceClient {
	return &wireGuardServiceClient{cc}
}

func (c *wireGuardServiceClient) GetWireGuardDevice(ctx context.Context, in *GetWireGuardDeviceRequest, opts ...grpc.CallOption) (*GetWireGuardDeviceResponse, error) {
	out := new(GetWireGuardDeviceResponse)
	err := c.cc.Invoke(ctx, "/api.v1.WireGuardService/GetWireGuardDevice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WireGuardServiceServer is the server API for WireGuardService service.
// All implementations must embed UnimplementedWireGuardServiceServer
// for forward compatibility
type WireGuardServiceServer interface {
	GetWireGuardDevice(context.Context, *GetWireGuardDeviceRequest) (*GetWireGuardDeviceResponse, error)
	mustEmbedUnimplementedWireGuardServiceServer()
}

// UnimplementedWireGuardServiceServer must be embedded to have forward compatible implementations.
type UnimplementedWireGuardServiceServer struct {
}

func (UnimplementedWireGuardServiceServer) GetWireGuardDevice(context.Context, *GetWireGuardDeviceRequest) (*GetWireGuardDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWireGuardDevice not implemented")
}
func (UnimplementedWireGuardServiceServer) mustEmbedUnimplementedWireGuardServiceServer() {}

// UnsafeWireGuardServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WireGuardServiceServer will
// result in compilation errors.
type UnsafeWireGuardServiceServer interface {
	mustEmbedUnimplementedWireGuardServiceServer()
}

func RegisterWireGuardServiceServer(s grpc.ServiceRegistrar, srv WireGuardServiceServer) {
	s.RegisterService(&WireGuardService_ServiceDesc, srv)
}

func _WireGuardService_GetWireGuardDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWireGuardDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WireGuardServiceServer).GetWireGuardDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.WireGuardService/GetWireGuardDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WireGuardServiceServer).GetWireGuardDevice(ctx, req.(*GetWireGuardDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WireGuardService_ServiceDesc is the grpc.ServiceDesc for WireGuardService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WireGuardService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v1.WireGuardService",
	HandlerType: (*WireGuardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetWireGuardDevice",
			Handler:    _WireGuardService_GetWireGuardDevice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/api.proto",
}

// ServerServiceClient is the client API for ServerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServerServiceClient interface {
	GetServerConfig(ctx context.Context, in *GetServerConfigRequest, opts ...grpc.CallOption) (*GetServerConfigResponse, error)
	GetServer(ctx context.Context, in *GetServerRequest, opts ...grpc.CallOption) (*GetServerResponse, error)
}

type serverServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewServerServiceClient(cc grpc.ClientConnInterface) ServerServiceClient {
	return &serverServiceClient{cc}
}

func (c *serverServiceClient) GetServerConfig(ctx context.Context, in *GetServerConfigRequest, opts ...grpc.CallOption) (*GetServerConfigResponse, error) {
	out := new(GetServerConfigResponse)
	err := c.cc.Invoke(ctx, "/api.v1.ServerService/GetServerConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) GetServer(ctx context.Context, in *GetServerRequest, opts ...grpc.CallOption) (*GetServerResponse, error) {
	out := new(GetServerResponse)
	err := c.cc.Invoke(ctx, "/api.v1.ServerService/GetServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServerServiceServer is the server API for ServerService service.
// All implementations must embed UnimplementedServerServiceServer
// for forward compatibility
type ServerServiceServer interface {
	GetServerConfig(context.Context, *GetServerConfigRequest) (*GetServerConfigResponse, error)
	GetServer(context.Context, *GetServerRequest) (*GetServerResponse, error)
	mustEmbedUnimplementedServerServiceServer()
}

// UnimplementedServerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedServerServiceServer struct {
}

func (UnimplementedServerServiceServer) GetServerConfig(context.Context, *GetServerConfigRequest) (*GetServerConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServerConfig not implemented")
}
func (UnimplementedServerServiceServer) GetServer(context.Context, *GetServerRequest) (*GetServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServer not implemented")
}
func (UnimplementedServerServiceServer) mustEmbedUnimplementedServerServiceServer() {}

// UnsafeServerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServerServiceServer will
// result in compilation errors.
type UnsafeServerServiceServer interface {
	mustEmbedUnimplementedServerServiceServer()
}

func RegisterServerServiceServer(s grpc.ServiceRegistrar, srv ServerServiceServer) {
	s.RegisterService(&ServerService_ServiceDesc, srv)
}

func _ServerService_GetServerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).GetServerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ServerService/GetServerConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).GetServerConfig(ctx, req.(*GetServerConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_GetServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).GetServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ServerService/GetServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).GetServer(ctx, req.(*GetServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ServerService_ServiceDesc is the grpc.ServiceDesc for ServerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v1.ServerService",
	HandlerType: (*ServerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServerConfig",
			Handler:    _ServerService_GetServerConfig_Handler,
		},
		{
			MethodName: "GetServer",
			Handler:    _ServerService_GetServer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/api.proto",
}

// TunnelServiceClient is the client API for TunnelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TunnelServiceClient interface {
	CreateTunnel(ctx context.Context, in *CreateTunnelRequest, opts ...grpc.CallOption) (*CreateTunnelResponse, error)
	GetTunnel(ctx context.Context, in *GetTunnelRequest, opts ...grpc.CallOption) (*GetTunnelResponse, error)
	ListTunnels(ctx context.Context, in *ListTunnelsRequest, opts ...grpc.CallOption) (*ListTunnelsResponse, error)
	RemoveTunnel(ctx context.Context, in *RemoveTunnelRequest, opts ...grpc.CallOption) (*RemoveTunnelResponse, error)
	UpdateDNSFilteringEnabled(ctx context.Context, in *UpdateDNSFilteringEnabledRequest, opts ...grpc.CallOption) (*UpdateDNSFilteringEnabledResponse, error)
	UpdateDNSBlockLists(ctx context.Context, in *UpdateDNSBlockListsRequest, opts ...grpc.CallOption) (*UpdateDNSBlockListsResponse, error)
	UpdateDNSFilteringRules(ctx context.Context, in *UpdateDNSFilteringRulesRequest, opts ...grpc.CallOption) (*UpdateDNSFilteringRulesResponse, error)
}

type tunnelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTunnelServiceClient(cc grpc.ClientConnInterface) TunnelServiceClient {
	return &tunnelServiceClient{cc}
}

func (c *tunnelServiceClient) CreateTunnel(ctx context.Context, in *CreateTunnelRequest, opts ...grpc.CallOption) (*CreateTunnelResponse, error) {
	out := new(CreateTunnelResponse)
	err := c.cc.Invoke(ctx, "/api.v1.TunnelService/CreateTunnel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tunnelServiceClient) GetTunnel(ctx context.Context, in *GetTunnelRequest, opts ...grpc.CallOption) (*GetTunnelResponse, error) {
	out := new(GetTunnelResponse)
	err := c.cc.Invoke(ctx, "/api.v1.TunnelService/GetTunnel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tunnelServiceClient) ListTunnels(ctx context.Context, in *ListTunnelsRequest, opts ...grpc.CallOption) (*ListTunnelsResponse, error) {
	out := new(ListTunnelsResponse)
	err := c.cc.Invoke(ctx, "/api.v1.TunnelService/ListTunnels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tunnelServiceClient) RemoveTunnel(ctx context.Context, in *RemoveTunnelRequest, opts ...grpc.CallOption) (*RemoveTunnelResponse, error) {
	out := new(RemoveTunnelResponse)
	err := c.cc.Invoke(ctx, "/api.v1.TunnelService/RemoveTunnel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tunnelServiceClient) UpdateDNSFilteringEnabled(ctx context.Context, in *UpdateDNSFilteringEnabledRequest, opts ...grpc.CallOption) (*UpdateDNSFilteringEnabledResponse, error) {
	out := new(UpdateDNSFilteringEnabledResponse)
	err := c.cc.Invoke(ctx, "/api.v1.TunnelService/UpdateDNSFilteringEnabled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tunnelServiceClient) UpdateDNSBlockLists(ctx context.Context, in *UpdateDNSBlockListsRequest, opts ...grpc.CallOption) (*UpdateDNSBlockListsResponse, error) {
	out := new(UpdateDNSBlockListsResponse)
	err := c.cc.Invoke(ctx, "/api.v1.TunnelService/UpdateDNSBlockLists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tunnelServiceClient) UpdateDNSFilteringRules(ctx context.Context, in *UpdateDNSFilteringRulesRequest, opts ...grpc.CallOption) (*UpdateDNSFilteringRulesResponse, error) {
	out := new(UpdateDNSFilteringRulesResponse)
	err := c.cc.Invoke(ctx, "/api.v1.TunnelService/UpdateDNSFilteringRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TunnelServiceServer is the server API for TunnelService service.
// All implementations must embed UnimplementedTunnelServiceServer
// for forward compatibility
type TunnelServiceServer interface {
	CreateTunnel(context.Context, *CreateTunnelRequest) (*CreateTunnelResponse, error)
	GetTunnel(context.Context, *GetTunnelRequest) (*GetTunnelResponse, error)
	ListTunnels(context.Context, *ListTunnelsRequest) (*ListTunnelsResponse, error)
	RemoveTunnel(context.Context, *RemoveTunnelRequest) (*RemoveTunnelResponse, error)
	UpdateDNSFilteringEnabled(context.Context, *UpdateDNSFilteringEnabledRequest) (*UpdateDNSFilteringEnabledResponse, error)
	UpdateDNSBlockLists(context.Context, *UpdateDNSBlockListsRequest) (*UpdateDNSBlockListsResponse, error)
	UpdateDNSFilteringRules(context.Context, *UpdateDNSFilteringRulesRequest) (*UpdateDNSFilteringRulesResponse, error)
	mustEmbedUnimplementedTunnelServiceServer()
}

// UnimplementedTunnelServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTunnelServiceServer struct {
}

func (UnimplementedTunnelServiceServer) CreateTunnel(context.Context, *CreateTunnelRequest) (*CreateTunnelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTunnel not implemented")
}
func (UnimplementedTunnelServiceServer) GetTunnel(context.Context, *GetTunnelRequest) (*GetTunnelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTunnel not implemented")
}
func (UnimplementedTunnelServiceServer) ListTunnels(context.Context, *ListTunnelsRequest) (*ListTunnelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTunnels not implemented")
}
func (UnimplementedTunnelServiceServer) RemoveTunnel(context.Context, *RemoveTunnelRequest) (*RemoveTunnelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveTunnel not implemented")
}
func (UnimplementedTunnelServiceServer) UpdateDNSFilteringEnabled(context.Context, *UpdateDNSFilteringEnabledRequest) (*UpdateDNSFilteringEnabledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDNSFilteringEnabled not implemented")
}
func (UnimplementedTunnelServiceServer) UpdateDNSBlockLists(context.Context, *UpdateDNSBlockListsRequest) (*UpdateDNSBlockListsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDNSBlockLists not implemented")
}
func (UnimplementedTunnelServiceServer) UpdateDNSFilteringRules(context.Context, *UpdateDNSFilteringRulesRequest) (*UpdateDNSFilteringRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDNSFilteringRules not implemented")
}
func (UnimplementedTunnelServiceServer) mustEmbedUnimplementedTunnelServiceServer() {}

// UnsafeTunnelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TunnelServiceServer will
// result in compilation errors.
type UnsafeTunnelServiceServer interface {
	mustEmbedUnimplementedTunnelServiceServer()
}

func RegisterTunnelServiceServer(s grpc.ServiceRegistrar, srv TunnelServiceServer) {
	s.RegisterService(&TunnelService_ServiceDesc, srv)
}

func _TunnelService_CreateTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TunnelServiceServer).CreateTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.TunnelService/CreateTunnel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TunnelServiceServer).CreateTunnel(ctx, req.(*CreateTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TunnelService_GetTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TunnelServiceServer).GetTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.TunnelService/GetTunnel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TunnelServiceServer).GetTunnel(ctx, req.(*GetTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TunnelService_ListTunnels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTunnelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TunnelServiceServer).ListTunnels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.TunnelService/ListTunnels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TunnelServiceServer).ListTunnels(ctx, req.(*ListTunnelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TunnelService_RemoveTunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TunnelServiceServer).RemoveTunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.TunnelService/RemoveTunnel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TunnelServiceServer).RemoveTunnel(ctx, req.(*RemoveTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TunnelService_UpdateDNSFilteringEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDNSFilteringEnabledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TunnelServiceServer).UpdateDNSFilteringEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.TunnelService/UpdateDNSFilteringEnabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TunnelServiceServer).UpdateDNSFilteringEnabled(ctx, req.(*UpdateDNSFilteringEnabledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TunnelService_UpdateDNSBlockLists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDNSBlockListsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TunnelServiceServer).UpdateDNSBlockLists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.TunnelService/UpdateDNSBlockLists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TunnelServiceServer).UpdateDNSBlockLists(ctx, req.(*UpdateDNSBlockListsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TunnelService_UpdateDNSFilteringRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDNSFilteringRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TunnelServiceServer).UpdateDNSFilteringRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.TunnelService/UpdateDNSFilteringRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TunnelServiceServer).UpdateDNSFilteringRules(ctx, req.(*UpdateDNSFilteringRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TunnelService_ServiceDesc is the grpc.ServiceDesc for TunnelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TunnelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v1.TunnelService",
	HandlerType: (*TunnelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTunnel",
			Handler:    _TunnelService_CreateTunnel_Handler,
		},
		{
			MethodName: "GetTunnel",
			Handler:    _TunnelService_GetTunnel_Handler,
		},
		{
			MethodName: "ListTunnels",
			Handler:    _TunnelService_ListTunnels_Handler,
		},
		{
			MethodName: "RemoveTunnel",
			Handler:    _TunnelService_RemoveTunnel_Handler,
		},
		{
			MethodName: "UpdateDNSFilteringEnabled",
			Handler:    _TunnelService_UpdateDNSFilteringEnabled_Handler,
		},
		{
			MethodName: "UpdateDNSBlockLists",
			Handler:    _TunnelService_UpdateDNSBlockLists_Handler,
		},
		{
			MethodName: "UpdateDNSFilteringRules",
			Handler:    _TunnelService_UpdateDNSFilteringRules_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/api.proto",
}

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
	Authenticate(ctx context.Context, in *AuthenticateRequest, opts ...grpc.CallOption) (*AuthenticateResponse, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) Authenticate(ctx context.Context, in *AuthenticateRequest, opts ...grpc.CallOption) (*AuthenticateResponse, error) {
	out := new(AuthenticateResponse)
	err := c.cc.Invoke(ctx, "/api.v1.AuthService/Authenticate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility
type AuthServiceServer interface {
	Authenticate(context.Context, *AuthenticateRequest) (*AuthenticateResponse, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (UnimplementedAuthServiceServer) Authenticate(context.Context, *AuthenticateRequest) (*AuthenticateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Authenticate not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_Authenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Authenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.AuthService/Authenticate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Authenticate(ctx, req.(*AuthenticateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v1.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Authenticate",
			Handler:    _AuthService_Authenticate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/api.proto",
}
