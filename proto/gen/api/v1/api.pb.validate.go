// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/v1/api.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetWireGuardDeviceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWireGuardDeviceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWireGuardDeviceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWireGuardDeviceRequestMultiError, or nil if none found.
func (m *GetWireGuardDeviceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWireGuardDeviceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetWireGuardDeviceRequestMultiError(errors)
	}

	return nil
}

// GetWireGuardDeviceRequestMultiError is an error wrapping multiple validation
// errors returned by GetWireGuardDeviceRequest.ValidateAll() if the
// designated constraints aren't met.
type GetWireGuardDeviceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWireGuardDeviceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWireGuardDeviceRequestMultiError) AllErrors() []error { return m }

// GetWireGuardDeviceRequestValidationError is the validation error returned by
// GetWireGuardDeviceRequest.Validate if the designated constraints aren't met.
type GetWireGuardDeviceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWireGuardDeviceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWireGuardDeviceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWireGuardDeviceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWireGuardDeviceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWireGuardDeviceRequestValidationError) ErrorName() string {
	return "GetWireGuardDeviceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWireGuardDeviceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWireGuardDeviceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWireGuardDeviceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWireGuardDeviceRequestValidationError{}

// Validate checks the field values on GetWireGuardDeviceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWireGuardDeviceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWireGuardDeviceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWireGuardDeviceResponseMultiError, or nil if none found.
func (m *GetWireGuardDeviceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWireGuardDeviceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDevice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWireGuardDeviceResponseValidationError{
					field:  "Device",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWireGuardDeviceResponseValidationError{
					field:  "Device",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDevice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWireGuardDeviceResponseValidationError{
				field:  "Device",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWireGuardDeviceResponseMultiError(errors)
	}

	return nil
}

// GetWireGuardDeviceResponseMultiError is an error wrapping multiple
// validation errors returned by GetWireGuardDeviceResponse.ValidateAll() if
// the designated constraints aren't met.
type GetWireGuardDeviceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWireGuardDeviceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWireGuardDeviceResponseMultiError) AllErrors() []error { return m }

// GetWireGuardDeviceResponseValidationError is the validation error returned
// by GetWireGuardDeviceResponse.Validate if the designated constraints aren't met.
type GetWireGuardDeviceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWireGuardDeviceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWireGuardDeviceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWireGuardDeviceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWireGuardDeviceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWireGuardDeviceResponseValidationError) ErrorName() string {
	return "GetWireGuardDeviceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetWireGuardDeviceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWireGuardDeviceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWireGuardDeviceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWireGuardDeviceResponseValidationError{}

// Validate checks the field values on WireGuardDevice with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WireGuardDevice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WireGuardDevice with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WireGuardDeviceMultiError, or nil if none found.
func (m *WireGuardDevice) ValidateAll() error {
	return m.validate(true)
}

func (m *WireGuardDevice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := WireGuardDeviceValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := WireGuardDevice_DeviceType_name[int32(m.GetType())]; !ok {
		err := WireGuardDeviceValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPublicKey()) < 1 {
		err := WireGuardDeviceValidationError{
			field:  "PublicKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetListenPort() < 0 {
		err := WireGuardDeviceValidationError{
			field:  "ListenPort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FirewallMark

	for idx, item := range m.GetPeers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WireGuardDeviceValidationError{
						field:  fmt.Sprintf("Peers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WireGuardDeviceValidationError{
						field:  fmt.Sprintf("Peers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WireGuardDeviceValidationError{
					field:  fmt.Sprintf("Peers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return WireGuardDeviceMultiError(errors)
	}

	return nil
}

// WireGuardDeviceMultiError is an error wrapping multiple validation errors
// returned by WireGuardDevice.ValidateAll() if the designated constraints
// aren't met.
type WireGuardDeviceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WireGuardDeviceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WireGuardDeviceMultiError) AllErrors() []error { return m }

// WireGuardDeviceValidationError is the validation error returned by
// WireGuardDevice.Validate if the designated constraints aren't met.
type WireGuardDeviceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WireGuardDeviceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WireGuardDeviceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WireGuardDeviceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WireGuardDeviceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WireGuardDeviceValidationError) ErrorName() string { return "WireGuardDeviceValidationError" }

// Error satisfies the builtin error interface
func (e WireGuardDeviceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWireGuardDevice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WireGuardDeviceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WireGuardDeviceValidationError{}

// Validate checks the field values on WireGuardDevicePeer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WireGuardDevicePeer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WireGuardDevicePeer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WireGuardDevicePeerMultiError, or nil if none found.
func (m *WireGuardDevicePeer) ValidateAll() error {
	return m.validate(true)
}

func (m *WireGuardDevicePeer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPublicKey()) < 1 {
		err := WireGuardDevicePeerValidationError{
			field:  "PublicKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPresharedKey()) < 1 {
		err := WireGuardDevicePeerValidationError{
			field:  "PresharedKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Endpoint

	if all {
		switch v := interface{}(m.GetPersistentKeepaliveInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WireGuardDevicePeerValidationError{
					field:  "PersistentKeepaliveInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WireGuardDevicePeerValidationError{
					field:  "PersistentKeepaliveInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPersistentKeepaliveInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WireGuardDevicePeerValidationError{
				field:  "PersistentKeepaliveInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastHandshakeTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WireGuardDevicePeerValidationError{
					field:  "LastHandshakeTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WireGuardDevicePeerValidationError{
					field:  "LastHandshakeTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastHandshakeTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WireGuardDevicePeerValidationError{
				field:  "LastHandshakeTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReceiveBytes

	// no validation rules for TransmitBytes

	for idx, item := range m.GetAllowedIps() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 1 {
			err := WireGuardDevicePeerValidationError{
				field:  fmt.Sprintf("AllowedIps[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for ProtocolVersion

	if len(errors) > 0 {
		return WireGuardDevicePeerMultiError(errors)
	}

	return nil
}

// WireGuardDevicePeerMultiError is an error wrapping multiple validation
// errors returned by WireGuardDevicePeer.ValidateAll() if the designated
// constraints aren't met.
type WireGuardDevicePeerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WireGuardDevicePeerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WireGuardDevicePeerMultiError) AllErrors() []error { return m }

// WireGuardDevicePeerValidationError is the validation error returned by
// WireGuardDevicePeer.Validate if the designated constraints aren't met.
type WireGuardDevicePeerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WireGuardDevicePeerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WireGuardDevicePeerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WireGuardDevicePeerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WireGuardDevicePeerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WireGuardDevicePeerValidationError) ErrorName() string {
	return "WireGuardDevicePeerValidationError"
}

// Error satisfies the builtin error interface
func (e WireGuardDevicePeerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWireGuardDevicePeer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WireGuardDevicePeerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WireGuardDevicePeerValidationError{}

// Validate checks the field values on Server with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Server) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Server with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ServerMultiError, or nil if none found.
func (m *Server) ValidateAll() error {
	return m.validate(true)
}

func (m *Server) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetConfig() == nil {
		err := ServerValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetStatus() == nil {
		err := ServerValidationError{
			field:  "Status",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServerMultiError(errors)
	}

	return nil
}

// ServerMultiError is an error wrapping multiple validation errors returned by
// Server.ValidateAll() if the designated constraints aren't met.
type ServerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerMultiError) AllErrors() []error { return m }

// ServerValidationError is the validation error returned by Server.Validate if
// the designated constraints aren't met.
type ServerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerValidationError) ErrorName() string { return "ServerValidationError" }

// Error satisfies the builtin error interface
func (e ServerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerValidationError{}

// Validate checks the field values on ServerConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServerConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServerConfigMultiError, or
// nil if none found.
func (m *ServerConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerConfigValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerConfigValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerConfigValidationError{
				field:  "Cluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetManager()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerConfigValidationError{
					field:  "Manager",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerConfigValidationError{
					field:  "Manager",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetManager()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerConfigValidationError{
				field:  "Manager",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWg()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerConfigValidationError{
					field:  "Wg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerConfigValidationError{
					field:  "Wg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWg()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerConfigValidationError{
				field:  "Wg",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCredentials()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerConfigValidationError{
					field:  "Credentials",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerConfigValidationError{
					field:  "Credentials",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCredentials()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerConfigValidationError{
				field:  "Credentials",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Debug

	if len(errors) > 0 {
		return ServerConfigMultiError(errors)
	}

	return nil
}

// ServerConfigMultiError is an error wrapping multiple validation errors
// returned by ServerConfig.ValidateAll() if the designated constraints aren't met.
type ServerConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerConfigMultiError) AllErrors() []error { return m }

// ServerConfigValidationError is the validation error returned by
// ServerConfig.Validate if the designated constraints aren't met.
type ServerConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerConfigValidationError) ErrorName() string { return "ServerConfigValidationError" }

// Error satisfies the builtin error interface
func (e ServerConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerConfigValidationError{}

// Validate checks the field values on ServerStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServerStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServerStatusMultiError, or
// nil if none found.
func (m *ServerStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if ip := net.ParseIP(m.GetMachineIp()); ip == nil {
		err := ServerStatusValidationError{
			field:  "MachineIp",
			reason: "value must be a valid IP address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetServerVersion()) < 1 {
		err := ServerStatusValidationError{
			field:  "ServerVersion",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetKubernetesDistribution()) < 1 {
		err := ServerStatusValidationError{
			field:  "KubernetesDistribution",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetKubernetesVersion()) < 1 {
		err := ServerStatusValidationError{
			field:  "KubernetesVersion",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ServerStatusMultiError(errors)
	}

	return nil
}

// ServerStatusMultiError is an error wrapping multiple validation errors
// returned by ServerStatus.ValidateAll() if the designated constraints aren't met.
type ServerStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerStatusMultiError) AllErrors() []error { return m }

// ServerStatusValidationError is the validation error returned by
// ServerStatus.Validate if the designated constraints aren't met.
type ServerStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerStatusValidationError) ErrorName() string { return "ServerStatusValidationError" }

// Error satisfies the builtin error interface
func (e ServerStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerStatusValidationError{}

// Validate checks the field values on GetServerConfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServerConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServerConfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServerConfigRequestMultiError, or nil if none found.
func (m *GetServerConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServerConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetServerConfigRequestMultiError(errors)
	}

	return nil
}

// GetServerConfigRequestMultiError is an error wrapping multiple validation
// errors returned by GetServerConfigRequest.ValidateAll() if the designated
// constraints aren't met.
type GetServerConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServerConfigRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServerConfigRequestMultiError) AllErrors() []error { return m }

// GetServerConfigRequestValidationError is the validation error returned by
// GetServerConfigRequest.Validate if the designated constraints aren't met.
type GetServerConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServerConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServerConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServerConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServerConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServerConfigRequestValidationError) ErrorName() string {
	return "GetServerConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetServerConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServerConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServerConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServerConfigRequestValidationError{}

// Validate checks the field values on GetServerConfigResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServerConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServerConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServerConfigResponseMultiError, or nil if none found.
func (m *GetServerConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServerConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServerConfigResponseValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServerConfigResponseValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServerConfigResponseValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServerConfigResponseMultiError(errors)
	}

	return nil
}

// GetServerConfigResponseMultiError is an error wrapping multiple validation
// errors returned by GetServerConfigResponse.ValidateAll() if the designated
// constraints aren't met.
type GetServerConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServerConfigResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServerConfigResponseMultiError) AllErrors() []error { return m }

// GetServerConfigResponseValidationError is the validation error returned by
// GetServerConfigResponse.Validate if the designated constraints aren't met.
type GetServerConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServerConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServerConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServerConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServerConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServerConfigResponseValidationError) ErrorName() string {
	return "GetServerConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetServerConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServerConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServerConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServerConfigResponseValidationError{}

// Validate checks the field values on GetServerRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetServerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServerRequestMultiError, or nil if none found.
func (m *GetServerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetServerRequestMultiError(errors)
	}

	return nil
}

// GetServerRequestMultiError is an error wrapping multiple validation errors
// returned by GetServerRequest.ValidateAll() if the designated constraints
// aren't met.
type GetServerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServerRequestMultiError) AllErrors() []error { return m }

// GetServerRequestValidationError is the validation error returned by
// GetServerRequest.Validate if the designated constraints aren't met.
type GetServerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServerRequestValidationError) ErrorName() string { return "GetServerRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetServerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServerRequestValidationError{}

// Validate checks the field values on GetServerResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetServerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServerResponseMultiError, or nil if none found.
func (m *GetServerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetServer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServerResponseValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServerResponseValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServerResponseValidationError{
				field:  "Server",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServerResponseMultiError(errors)
	}

	return nil
}

// GetServerResponseMultiError is an error wrapping multiple validation errors
// returned by GetServerResponse.ValidateAll() if the designated constraints
// aren't met.
type GetServerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServerResponseMultiError) AllErrors() []error { return m }

// GetServerResponseValidationError is the validation error returned by
// GetServerResponse.Validate if the designated constraints aren't met.
type GetServerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServerResponseValidationError) ErrorName() string {
	return "GetServerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetServerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServerResponseValidationError{}

// Validate checks the field values on CreateTunnelRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTunnelRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTunnelRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTunnelRequestMultiError, or nil if none found.
func (m *CreateTunnelRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTunnelRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetAg()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTunnelRequestValidationError{
					field:  "Ag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTunnelRequestValidationError{
					field:  "Ag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAg()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTunnelRequestValidationError{
				field:  "Ag",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTunnelRequestMultiError(errors)
	}

	return nil
}

// CreateTunnelRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTunnelRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTunnelRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTunnelRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTunnelRequestMultiError) AllErrors() []error { return m }

// CreateTunnelRequestValidationError is the validation error returned by
// CreateTunnelRequest.Validate if the designated constraints aren't met.
type CreateTunnelRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTunnelRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTunnelRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTunnelRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTunnelRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTunnelRequestValidationError) ErrorName() string {
	return "CreateTunnelRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTunnelRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTunnelRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTunnelRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTunnelRequestValidationError{}

// Validate checks the field values on CreateTunnelResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTunnelResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTunnelResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTunnelResponseMultiError, or nil if none found.
func (m *CreateTunnelResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTunnelResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTunnel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTunnelResponseValidationError{
					field:  "Tunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTunnelResponseValidationError{
					field:  "Tunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTunnel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTunnelResponseValidationError{
				field:  "Tunnel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTunnelResponseMultiError(errors)
	}

	return nil
}

// CreateTunnelResponseMultiError is an error wrapping multiple validation
// errors returned by CreateTunnelResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTunnelResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTunnelResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTunnelResponseMultiError) AllErrors() []error { return m }

// CreateTunnelResponseValidationError is the validation error returned by
// CreateTunnelResponse.Validate if the designated constraints aren't met.
type CreateTunnelResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTunnelResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTunnelResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTunnelResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTunnelResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTunnelResponseValidationError) ErrorName() string {
	return "CreateTunnelResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTunnelResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTunnelResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTunnelResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTunnelResponseValidationError{}

// Validate checks the field values on GetTunnelRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetTunnelRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTunnelRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTunnelRequestMultiError, or nil if none found.
func (m *GetTunnelRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTunnelRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := GetTunnelRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTunnelRequestMultiError(errors)
	}

	return nil
}

// GetTunnelRequestMultiError is an error wrapping multiple validation errors
// returned by GetTunnelRequest.ValidateAll() if the designated constraints
// aren't met.
type GetTunnelRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTunnelRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTunnelRequestMultiError) AllErrors() []error { return m }

// GetTunnelRequestValidationError is the validation error returned by
// GetTunnelRequest.Validate if the designated constraints aren't met.
type GetTunnelRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTunnelRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTunnelRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTunnelRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTunnelRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTunnelRequestValidationError) ErrorName() string { return "GetTunnelRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetTunnelRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTunnelRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTunnelRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTunnelRequestValidationError{}

// Validate checks the field values on GetTunnelResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetTunnelResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTunnelResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTunnelResponseMultiError, or nil if none found.
func (m *GetTunnelResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTunnelResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTunnel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTunnelResponseValidationError{
					field:  "Tunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTunnelResponseValidationError{
					field:  "Tunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTunnel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTunnelResponseValidationError{
				field:  "Tunnel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTunnelResponseMultiError(errors)
	}

	return nil
}

// GetTunnelResponseMultiError is an error wrapping multiple validation errors
// returned by GetTunnelResponse.ValidateAll() if the designated constraints
// aren't met.
type GetTunnelResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTunnelResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTunnelResponseMultiError) AllErrors() []error { return m }

// GetTunnelResponseValidationError is the validation error returned by
// GetTunnelResponse.Validate if the designated constraints aren't met.
type GetTunnelResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTunnelResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTunnelResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTunnelResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTunnelResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTunnelResponseValidationError) ErrorName() string {
	return "GetTunnelResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTunnelResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTunnelResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTunnelResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTunnelResponseValidationError{}

// Validate checks the field values on ListTunnelsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTunnelsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTunnelsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTunnelsRequestMultiError, or nil if none found.
func (m *ListTunnelsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTunnelsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListTunnelsRequestMultiError(errors)
	}

	return nil
}

// ListTunnelsRequestMultiError is an error wrapping multiple validation errors
// returned by ListTunnelsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListTunnelsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTunnelsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTunnelsRequestMultiError) AllErrors() []error { return m }

// ListTunnelsRequestValidationError is the validation error returned by
// ListTunnelsRequest.Validate if the designated constraints aren't met.
type ListTunnelsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTunnelsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTunnelsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTunnelsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTunnelsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTunnelsRequestValidationError) ErrorName() string {
	return "ListTunnelsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTunnelsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTunnelsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTunnelsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTunnelsRequestValidationError{}

// Validate checks the field values on ListTunnelsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTunnelsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTunnelsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTunnelsResponseMultiError, or nil if none found.
func (m *ListTunnelsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTunnelsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTunnels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTunnelsResponseValidationError{
						field:  fmt.Sprintf("Tunnels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTunnelsResponseValidationError{
						field:  fmt.Sprintf("Tunnels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTunnelsResponseValidationError{
					field:  fmt.Sprintf("Tunnels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTunnelsResponseMultiError(errors)
	}

	return nil
}

// ListTunnelsResponseMultiError is an error wrapping multiple validation
// errors returned by ListTunnelsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListTunnelsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTunnelsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTunnelsResponseMultiError) AllErrors() []error { return m }

// ListTunnelsResponseValidationError is the validation error returned by
// ListTunnelsResponse.Validate if the designated constraints aren't met.
type ListTunnelsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTunnelsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTunnelsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTunnelsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTunnelsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTunnelsResponseValidationError) ErrorName() string {
	return "ListTunnelsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTunnelsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTunnelsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTunnelsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTunnelsResponseValidationError{}

// Validate checks the field values on RemoveTunnelRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveTunnelRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveTunnelRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveTunnelRequestMultiError, or nil if none found.
func (m *RemoveTunnelRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveTunnelRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := RemoveTunnelRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RemoveTunnelRequestMultiError(errors)
	}

	return nil
}

// RemoveTunnelRequestMultiError is an error wrapping multiple validation
// errors returned by RemoveTunnelRequest.ValidateAll() if the designated
// constraints aren't met.
type RemoveTunnelRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveTunnelRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveTunnelRequestMultiError) AllErrors() []error { return m }

// RemoveTunnelRequestValidationError is the validation error returned by
// RemoveTunnelRequest.Validate if the designated constraints aren't met.
type RemoveTunnelRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveTunnelRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveTunnelRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveTunnelRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveTunnelRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveTunnelRequestValidationError) ErrorName() string {
	return "RemoveTunnelRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveTunnelRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveTunnelRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveTunnelRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveTunnelRequestValidationError{}

// Validate checks the field values on RemoveTunnelResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveTunnelResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveTunnelResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveTunnelResponseMultiError, or nil if none found.
func (m *RemoveTunnelResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveTunnelResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RemoveTunnelResponseMultiError(errors)
	}

	return nil
}

// RemoveTunnelResponseMultiError is an error wrapping multiple validation
// errors returned by RemoveTunnelResponse.ValidateAll() if the designated
// constraints aren't met.
type RemoveTunnelResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveTunnelResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveTunnelResponseMultiError) AllErrors() []error { return m }

// RemoveTunnelResponseValidationError is the validation error returned by
// RemoveTunnelResponse.Validate if the designated constraints aren't met.
type RemoveTunnelResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveTunnelResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveTunnelResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveTunnelResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveTunnelResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveTunnelResponseValidationError) ErrorName() string {
	return "RemoveTunnelResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveTunnelResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveTunnelResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveTunnelResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveTunnelResponseValidationError{}

// Validate checks the field values on UpdateDNSFilteringEnabledRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateDNSFilteringEnabledRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDNSFilteringEnabledRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDNSFilteringEnabledRequestMultiError, or nil if none found.
func (m *UpdateDNSFilteringEnabledRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDNSFilteringEnabledRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := UpdateDNSFilteringEnabledRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FilteringEnabled

	if len(errors) > 0 {
		return UpdateDNSFilteringEnabledRequestMultiError(errors)
	}

	return nil
}

// UpdateDNSFilteringEnabledRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateDNSFilteringEnabledRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateDNSFilteringEnabledRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDNSFilteringEnabledRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDNSFilteringEnabledRequestMultiError) AllErrors() []error { return m }

// UpdateDNSFilteringEnabledRequestValidationError is the validation error
// returned by UpdateDNSFilteringEnabledRequest.Validate if the designated
// constraints aren't met.
type UpdateDNSFilteringEnabledRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDNSFilteringEnabledRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDNSFilteringEnabledRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDNSFilteringEnabledRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDNSFilteringEnabledRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDNSFilteringEnabledRequestValidationError) ErrorName() string {
	return "UpdateDNSFilteringEnabledRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDNSFilteringEnabledRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDNSFilteringEnabledRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDNSFilteringEnabledRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDNSFilteringEnabledRequestValidationError{}

// Validate checks the field values on UpdateDNSFilteringEnabledResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateDNSFilteringEnabledResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDNSFilteringEnabledResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateDNSFilteringEnabledResponseMultiError, or nil if none found.
func (m *UpdateDNSFilteringEnabledResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDNSFilteringEnabledResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateDNSFilteringEnabledResponseMultiError(errors)
	}

	return nil
}

// UpdateDNSFilteringEnabledResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateDNSFilteringEnabledResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateDNSFilteringEnabledResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDNSFilteringEnabledResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDNSFilteringEnabledResponseMultiError) AllErrors() []error { return m }

// UpdateDNSFilteringEnabledResponseValidationError is the validation error
// returned by UpdateDNSFilteringEnabledResponse.Validate if the designated
// constraints aren't met.
type UpdateDNSFilteringEnabledResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDNSFilteringEnabledResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDNSFilteringEnabledResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDNSFilteringEnabledResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDNSFilteringEnabledResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDNSFilteringEnabledResponseValidationError) ErrorName() string {
	return "UpdateDNSFilteringEnabledResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDNSFilteringEnabledResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDNSFilteringEnabledResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDNSFilteringEnabledResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDNSFilteringEnabledResponseValidationError{}

// Validate checks the field values on UpdateDNSBlockListsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDNSBlockListsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDNSBlockListsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDNSBlockListsRequestMultiError, or nil if none found.
func (m *UpdateDNSBlockListsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDNSBlockListsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := UpdateDNSBlockListsRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetBlockLists() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDNSBlockListsRequestValidationError{
						field:  fmt.Sprintf("BlockLists[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDNSBlockListsRequestValidationError{
						field:  fmt.Sprintf("BlockLists[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDNSBlockListsRequestValidationError{
					field:  fmt.Sprintf("BlockLists[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDNSBlockListsRequestMultiError(errors)
	}

	return nil
}

// UpdateDNSBlockListsRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDNSBlockListsRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateDNSBlockListsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDNSBlockListsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDNSBlockListsRequestMultiError) AllErrors() []error { return m }

// UpdateDNSBlockListsRequestValidationError is the validation error returned
// by UpdateDNSBlockListsRequest.Validate if the designated constraints aren't met.
type UpdateDNSBlockListsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDNSBlockListsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDNSBlockListsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDNSBlockListsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDNSBlockListsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDNSBlockListsRequestValidationError) ErrorName() string {
	return "UpdateDNSBlockListsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDNSBlockListsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDNSBlockListsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDNSBlockListsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDNSBlockListsRequestValidationError{}

// Validate checks the field values on UpdateDNSBlockListsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDNSBlockListsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDNSBlockListsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDNSBlockListsResponseMultiError, or nil if none found.
func (m *UpdateDNSBlockListsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDNSBlockListsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateDNSBlockListsResponseMultiError(errors)
	}

	return nil
}

// UpdateDNSBlockListsResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateDNSBlockListsResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateDNSBlockListsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDNSBlockListsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDNSBlockListsResponseMultiError) AllErrors() []error { return m }

// UpdateDNSBlockListsResponseValidationError is the validation error returned
// by UpdateDNSBlockListsResponse.Validate if the designated constraints
// aren't met.
type UpdateDNSBlockListsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDNSBlockListsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDNSBlockListsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDNSBlockListsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDNSBlockListsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDNSBlockListsResponseValidationError) ErrorName() string {
	return "UpdateDNSBlockListsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDNSBlockListsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDNSBlockListsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDNSBlockListsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDNSBlockListsResponseValidationError{}

// Validate checks the field values on UpdateDNSFilteringRulesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDNSFilteringRulesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDNSFilteringRulesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDNSFilteringRulesRequestMultiError, or nil if none found.
func (m *UpdateDNSFilteringRulesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDNSFilteringRulesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := UpdateDNSFilteringRulesRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDNSFilteringRulesRequestValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDNSFilteringRulesRequestValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDNSFilteringRulesRequestValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDNSFilteringRulesRequestMultiError(errors)
	}

	return nil
}

// UpdateDNSFilteringRulesRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDNSFilteringRulesRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateDNSFilteringRulesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDNSFilteringRulesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDNSFilteringRulesRequestMultiError) AllErrors() []error { return m }

// UpdateDNSFilteringRulesRequestValidationError is the validation error
// returned by UpdateDNSFilteringRulesRequest.Validate if the designated
// constraints aren't met.
type UpdateDNSFilteringRulesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDNSFilteringRulesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDNSFilteringRulesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDNSFilteringRulesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDNSFilteringRulesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDNSFilteringRulesRequestValidationError) ErrorName() string {
	return "UpdateDNSFilteringRulesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDNSFilteringRulesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDNSFilteringRulesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDNSFilteringRulesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDNSFilteringRulesRequestValidationError{}

// Validate checks the field values on UpdateDNSFilteringRulesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDNSFilteringRulesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDNSFilteringRulesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDNSFilteringRulesResponseMultiError, or nil if none found.
func (m *UpdateDNSFilteringRulesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDNSFilteringRulesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateDNSFilteringRulesResponseMultiError(errors)
	}

	return nil
}

// UpdateDNSFilteringRulesResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateDNSFilteringRulesResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateDNSFilteringRulesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDNSFilteringRulesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDNSFilteringRulesResponseMultiError) AllErrors() []error { return m }

// UpdateDNSFilteringRulesResponseValidationError is the validation error
// returned by UpdateDNSFilteringRulesResponse.Validate if the designated
// constraints aren't met.
type UpdateDNSFilteringRulesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDNSFilteringRulesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDNSFilteringRulesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDNSFilteringRulesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDNSFilteringRulesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDNSFilteringRulesResponseValidationError) ErrorName() string {
	return "UpdateDNSFilteringRulesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDNSFilteringRulesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDNSFilteringRulesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDNSFilteringRulesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDNSFilteringRulesResponseValidationError{}

// Validate checks the field values on TunnelConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TunnelConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TunnelConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TunnelConfigMultiError, or
// nil if none found.
func (m *TunnelConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TunnelConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofProtocolPresent := false
	switch v := m.Protocol.(type) {
	case *TunnelConfig_Wg:
		if v == nil {
			err := TunnelConfigValidationError{
				field:  "Protocol",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofProtocolPresent = true

		if all {
			switch v := interface{}(m.GetWg()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TunnelConfigValidationError{
						field:  "Wg",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TunnelConfigValidationError{
						field:  "Wg",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWg()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TunnelConfigValidationError{
					field:  "Wg",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofProtocolPresent {
		err := TunnelConfigValidationError{
			field:  "Protocol",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}
	oneofDnsPresent := false
	switch v := m.Dns.(type) {
	case *TunnelConfig_Ag:
		if v == nil {
			err := TunnelConfigValidationError{
				field:  "Dns",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofDnsPresent = true

		if all {
			switch v := interface{}(m.GetAg()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TunnelConfigValidationError{
						field:  "Ag",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TunnelConfigValidationError{
						field:  "Ag",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAg()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TunnelConfigValidationError{
					field:  "Ag",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofDnsPresent {
		err := TunnelConfigValidationError{
			field:  "Dns",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TunnelConfigMultiError(errors)
	}

	return nil
}

// TunnelConfigMultiError is an error wrapping multiple validation errors
// returned by TunnelConfig.ValidateAll() if the designated constraints aren't met.
type TunnelConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TunnelConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TunnelConfigMultiError) AllErrors() []error { return m }

// TunnelConfigValidationError is the validation error returned by
// TunnelConfig.Validate if the designated constraints aren't met.
type TunnelConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TunnelConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TunnelConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TunnelConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TunnelConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TunnelConfigValidationError) ErrorName() string { return "TunnelConfigValidationError" }

// Error satisfies the builtin error interface
func (e TunnelConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTunnelConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TunnelConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TunnelConfigValidationError{}

// Validate checks the field values on WireGuardConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WireGuardConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WireGuardConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WireGuardConfigMultiError, or nil if none found.
func (m *WireGuardConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *WireGuardConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetInterface() == nil {
		err := WireGuardConfigValidationError{
			field:  "Interface",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetInterface()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WireGuardConfigValidationError{
					field:  "Interface",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WireGuardConfigValidationError{
					field:  "Interface",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterface()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WireGuardConfigValidationError{
				field:  "Interface",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPeers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WireGuardConfigValidationError{
						field:  fmt.Sprintf("Peers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WireGuardConfigValidationError{
						field:  fmt.Sprintf("Peers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WireGuardConfigValidationError{
					field:  fmt.Sprintf("Peers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for WgConfig

	if len(errors) > 0 {
		return WireGuardConfigMultiError(errors)
	}

	return nil
}

// WireGuardConfigMultiError is an error wrapping multiple validation errors
// returned by WireGuardConfig.ValidateAll() if the designated constraints
// aren't met.
type WireGuardConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WireGuardConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WireGuardConfigMultiError) AllErrors() []error { return m }

// WireGuardConfigValidationError is the validation error returned by
// WireGuardConfig.Validate if the designated constraints aren't met.
type WireGuardConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WireGuardConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WireGuardConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WireGuardConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WireGuardConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WireGuardConfigValidationError) ErrorName() string { return "WireGuardConfigValidationError" }

// Error satisfies the builtin error interface
func (e WireGuardConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWireGuardConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WireGuardConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WireGuardConfigValidationError{}

// Validate checks the field values on WireGuardInterface with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WireGuardInterface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WireGuardInterface with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WireGuardInterfaceMultiError, or nil if none found.
func (m *WireGuardInterface) ValidateAll() error {
	return m.validate(true)
}

func (m *WireGuardInterface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPrivateKey()) < 1 {
		err := WireGuardInterfaceValidationError{
			field:  "PrivateKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetListenPort(); val < 1 || val > 65535 {
		err := WireGuardInterfaceValidationError{
			field:  "ListenPort",
			reason: "value must be inside range [1, 65535]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetIngressPort() != 0 {

		if val := m.GetIngressPort(); val < 30000 || val > 32767 {
			err := WireGuardInterfaceValidationError{
				field:  "IngressPort",
				reason: "value must be inside range [30000, 32767]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for FirewallMark

	for idx, item := range m.GetAddress() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 1 {
			err := WireGuardInterfaceValidationError{
				field:  fmt.Sprintf("Address[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetDns() {
		_, _ = idx, item

		if ip := net.ParseIP(item); ip == nil {
			err := WireGuardInterfaceValidationError{
				field:  fmt.Sprintf("Dns[%v]", idx),
				reason: "value must be a valid IP address",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetMtu() < 0 {
		err := WireGuardInterfaceValidationError{
			field:  "Mtu",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTable() < 0 {
		err := WireGuardInterfaceValidationError{
			field:  "Table",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PreUp

	// no validation rules for PostUp

	// no validation rules for PreDown

	// no validation rules for PostDown

	if len(errors) > 0 {
		return WireGuardInterfaceMultiError(errors)
	}

	return nil
}

// WireGuardInterfaceMultiError is an error wrapping multiple validation errors
// returned by WireGuardInterface.ValidateAll() if the designated constraints
// aren't met.
type WireGuardInterfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WireGuardInterfaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WireGuardInterfaceMultiError) AllErrors() []error { return m }

// WireGuardInterfaceValidationError is the validation error returned by
// WireGuardInterface.Validate if the designated constraints aren't met.
type WireGuardInterfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WireGuardInterfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WireGuardInterfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WireGuardInterfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WireGuardInterfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WireGuardInterfaceValidationError) ErrorName() string {
	return "WireGuardInterfaceValidationError"
}

// Error satisfies the builtin error interface
func (e WireGuardInterfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWireGuardInterface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WireGuardInterfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WireGuardInterfaceValidationError{}

// Validate checks the field values on WireGuardPeer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WireGuardPeer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WireGuardPeer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WireGuardPeerMultiError, or
// nil if none found.
func (m *WireGuardPeer) ValidateAll() error {
	return m.validate(true)
}

func (m *WireGuardPeer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPublicKey()) < 1 {
		err := WireGuardPeerValidationError{
			field:  "PublicKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PresharedKey

	// no validation rules for Endpoint

	if d := m.GetPersistentKeepaliveInterval(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = WireGuardPeerValidationError{
				field:  "PersistentKeepaliveInterval",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			gte := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur < gte {
				err := WireGuardPeerValidationError{
					field:  "PersistentKeepaliveInterval",
					reason: "value must be greater than or equal to 0s",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	for idx, item := range m.GetAllowedIps() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 1 {
			err := WireGuardPeerValidationError{
				field:  fmt.Sprintf("AllowedIps[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return WireGuardPeerMultiError(errors)
	}

	return nil
}

// WireGuardPeerMultiError is an error wrapping multiple validation errors
// returned by WireGuardPeer.ValidateAll() if the designated constraints
// aren't met.
type WireGuardPeerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WireGuardPeerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WireGuardPeerMultiError) AllErrors() []error { return m }

// WireGuardPeerValidationError is the validation error returned by
// WireGuardPeer.Validate if the designated constraints aren't met.
type WireGuardPeerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WireGuardPeerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WireGuardPeerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WireGuardPeerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WireGuardPeerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WireGuardPeerValidationError) ErrorName() string { return "WireGuardPeerValidationError" }

// Error satisfies the builtin error interface
func (e WireGuardPeerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWireGuardPeer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WireGuardPeerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WireGuardPeerValidationError{}

// Validate checks the field values on AdGuardConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AdGuardConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdGuardConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AdGuardConfigMultiError, or
// nil if none found.
func (m *AdGuardConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AdGuardConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBlockLists() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdGuardConfigValidationError{
						field:  fmt.Sprintf("BlockLists[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdGuardConfigValidationError{
						field:  fmt.Sprintf("BlockLists[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdGuardConfigValidationError{
					field:  fmt.Sprintf("BlockLists[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdGuardConfigValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdGuardConfigValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdGuardConfigValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.FilteringEnabled != nil {
		// no validation rules for FilteringEnabled
	}

	if len(errors) > 0 {
		return AdGuardConfigMultiError(errors)
	}

	return nil
}

// AdGuardConfigMultiError is an error wrapping multiple validation errors
// returned by AdGuardConfig.ValidateAll() if the designated constraints
// aren't met.
type AdGuardConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdGuardConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdGuardConfigMultiError) AllErrors() []error { return m }

// AdGuardConfigValidationError is the validation error returned by
// AdGuardConfig.Validate if the designated constraints aren't met.
type AdGuardConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdGuardConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdGuardConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdGuardConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdGuardConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdGuardConfigValidationError) ErrorName() string { return "AdGuardConfigValidationError" }

// Error satisfies the builtin error interface
func (e AdGuardConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdGuardConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdGuardConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdGuardConfigValidationError{}

// Validate checks the field values on Tunnel with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Tunnel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Tunnel with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TunnelMultiError, or nil if none found.
func (m *Tunnel) ValidateAll() error {
	return m.validate(true)
}

func (m *Tunnel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := TunnelValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TunnelValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TunnelValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TunnelValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TunnelValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TunnelValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TunnelValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TunnelValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TunnelValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TunnelValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TunnelValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TunnelValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TunnelValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TunnelMultiError(errors)
	}

	return nil
}

// TunnelMultiError is an error wrapping multiple validation errors returned by
// Tunnel.ValidateAll() if the designated constraints aren't met.
type TunnelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TunnelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TunnelMultiError) AllErrors() []error { return m }

// TunnelValidationError is the validation error returned by Tunnel.Validate if
// the designated constraints aren't met.
type TunnelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TunnelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TunnelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TunnelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TunnelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TunnelValidationError) ErrorName() string { return "TunnelValidationError" }

// Error satisfies the builtin error interface
func (e TunnelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTunnel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TunnelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TunnelValidationError{}

// Validate checks the field values on TunnelStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TunnelStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TunnelStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TunnelStatusMultiError, or
// nil if none found.
func (m *TunnelStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *TunnelStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for State

	// no validation rules for Details

	switch v := m.Protocol.(type) {
	case *TunnelStatus_Wg:
		if v == nil {
			err := TunnelStatusValidationError{
				field:  "Protocol",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWg()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TunnelStatusValidationError{
						field:  "Wg",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TunnelStatusValidationError{
						field:  "Wg",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWg()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TunnelStatusValidationError{
					field:  "Wg",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	switch v := m.Dns.(type) {
	case *TunnelStatus_Ag:
		if v == nil {
			err := TunnelStatusValidationError{
				field:  "Dns",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAg()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TunnelStatusValidationError{
						field:  "Ag",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TunnelStatusValidationError{
						field:  "Ag",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAg()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TunnelStatusValidationError{
					field:  "Ag",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TunnelStatusMultiError(errors)
	}

	return nil
}

// TunnelStatusMultiError is an error wrapping multiple validation errors
// returned by TunnelStatus.ValidateAll() if the designated constraints aren't met.
type TunnelStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TunnelStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TunnelStatusMultiError) AllErrors() []error { return m }

// TunnelStatusValidationError is the validation error returned by
// TunnelStatus.Validate if the designated constraints aren't met.
type TunnelStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TunnelStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TunnelStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TunnelStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TunnelStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TunnelStatusValidationError) ErrorName() string { return "TunnelStatusValidationError" }

// Error satisfies the builtin error interface
func (e TunnelStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTunnelStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TunnelStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TunnelStatusValidationError{}

// Validate checks the field values on WireGuardStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WireGuardStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WireGuardStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WireGuardStatusMultiError, or nil if none found.
func (m *WireGuardStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *WireGuardStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDevice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WireGuardStatusValidationError{
					field:  "Device",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WireGuardStatusValidationError{
					field:  "Device",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDevice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WireGuardStatusValidationError{
				field:  "Device",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WireGuardStatusMultiError(errors)
	}

	return nil
}

// WireGuardStatusMultiError is an error wrapping multiple validation errors
// returned by WireGuardStatus.ValidateAll() if the designated constraints
// aren't met.
type WireGuardStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WireGuardStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WireGuardStatusMultiError) AllErrors() []error { return m }

// WireGuardStatusValidationError is the validation error returned by
// WireGuardStatus.Validate if the designated constraints aren't met.
type WireGuardStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WireGuardStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WireGuardStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WireGuardStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WireGuardStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WireGuardStatusValidationError) ErrorName() string { return "WireGuardStatusValidationError" }

// Error satisfies the builtin error interface
func (e WireGuardStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWireGuardStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WireGuardStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WireGuardStatusValidationError{}

// Validate checks the field values on AdGuardStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AdGuardStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdGuardStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AdGuardStatusMultiError, or
// nil if none found.
func (m *AdGuardStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *AdGuardStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetQueryLogs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdGuardStatusValidationError{
						field:  fmt.Sprintf("QueryLogs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdGuardStatusValidationError{
						field:  fmt.Sprintf("QueryLogs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdGuardStatusValidationError{
					field:  fmt.Sprintf("QueryLogs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AdGuardStatusMultiError(errors)
	}

	return nil
}

// AdGuardStatusMultiError is an error wrapping multiple validation errors
// returned by AdGuardStatus.ValidateAll() if the designated constraints
// aren't met.
type AdGuardStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdGuardStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdGuardStatusMultiError) AllErrors() []error { return m }

// AdGuardStatusValidationError is the validation error returned by
// AdGuardStatus.Validate if the designated constraints aren't met.
type AdGuardStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdGuardStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdGuardStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdGuardStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdGuardStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdGuardStatusValidationError) ErrorName() string { return "AdGuardStatusValidationError" }

// Error satisfies the builtin error interface
func (e AdGuardStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdGuardStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdGuardStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdGuardStatusValidationError{}

// Validate checks the field values on ServerConfig_Cluster with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServerConfig_Cluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerConfig_Cluster with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServerConfig_ClusterMultiError, or nil if none found.
func (m *ServerConfig_Cluster) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerConfig_Cluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKubeConfig()) < 1 {
		err := ServerConfig_ClusterValidationError{
			field:  "KubeConfig",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Host

	switch v := m.Distribution.(type) {
	case *ServerConfig_Cluster_K3S_:
		if v == nil {
			err := ServerConfig_ClusterValidationError{
				field:  "Distribution",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetK3S()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerConfig_ClusterValidationError{
						field:  "K3S",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerConfig_ClusterValidationError{
						field:  "K3S",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetK3S()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerConfig_ClusterValidationError{
					field:  "K3S",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServerConfig_Cluster_K3D_:
		if v == nil {
			err := ServerConfig_ClusterValidationError{
				field:  "Distribution",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetK3D()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerConfig_ClusterValidationError{
						field:  "K3D",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerConfig_ClusterValidationError{
						field:  "K3D",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetK3D()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerConfig_ClusterValidationError{
					field:  "K3D",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ServerConfig_ClusterMultiError(errors)
	}

	return nil
}

// ServerConfig_ClusterMultiError is an error wrapping multiple validation
// errors returned by ServerConfig_Cluster.ValidateAll() if the designated
// constraints aren't met.
type ServerConfig_ClusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerConfig_ClusterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerConfig_ClusterMultiError) AllErrors() []error { return m }

// ServerConfig_ClusterValidationError is the validation error returned by
// ServerConfig_Cluster.Validate if the designated constraints aren't met.
type ServerConfig_ClusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerConfig_ClusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerConfig_ClusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerConfig_ClusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerConfig_ClusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerConfig_ClusterValidationError) ErrorName() string {
	return "ServerConfig_ClusterValidationError"
}

// Error satisfies the builtin error interface
func (e ServerConfig_ClusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerConfig_Cluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerConfig_ClusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerConfig_ClusterValidationError{}

// Validate checks the field values on ServerConfig_Image with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServerConfig_Image) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerConfig_Image with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServerConfig_ImageMultiError, or nil if none found.
func (m *ServerConfig_Image) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerConfig_Image) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetImage()) < 1 {
		err := ServerConfig_ImageValidationError{
			field:  "Image",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ServerConfig_Image_ImagePullPolicy_name[int32(m.GetImagePullPolicy())]; !ok {
		err := ServerConfig_ImageValidationError{
			field:  "ImagePullPolicy",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetImagePullSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerConfig_ImageValidationError{
					field:  "ImagePullSecret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerConfig_ImageValidationError{
					field:  "ImagePullSecret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImagePullSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerConfig_ImageValidationError{
				field:  "ImagePullSecret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServerConfig_ImageMultiError(errors)
	}

	return nil
}

// ServerConfig_ImageMultiError is an error wrapping multiple validation errors
// returned by ServerConfig_Image.ValidateAll() if the designated constraints
// aren't met.
type ServerConfig_ImageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerConfig_ImageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerConfig_ImageMultiError) AllErrors() []error { return m }

// ServerConfig_ImageValidationError is the validation error returned by
// ServerConfig_Image.Validate if the designated constraints aren't met.
type ServerConfig_ImageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerConfig_ImageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerConfig_ImageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerConfig_ImageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerConfig_ImageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerConfig_ImageValidationError) ErrorName() string {
	return "ServerConfig_ImageValidationError"
}

// Error satisfies the builtin error interface
func (e ServerConfig_ImageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerConfig_Image.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerConfig_ImageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerConfig_ImageValidationError{}

// Validate checks the field values on ServerConfig_Credentials with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServerConfig_Credentials) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerConfig_Credentials with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServerConfig_CredentialsMultiError, or nil if none found.
func (m *ServerConfig_Credentials) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerConfig_Credentials) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetApi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerConfig_CredentialsValidationError{
					field:  "Api",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerConfig_CredentialsValidationError{
					field:  "Api",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerConfig_CredentialsValidationError{
				field:  "Api",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServerConfig_CredentialsMultiError(errors)
	}

	return nil
}

// ServerConfig_CredentialsMultiError is an error wrapping multiple validation
// errors returned by ServerConfig_Credentials.ValidateAll() if the designated
// constraints aren't met.
type ServerConfig_CredentialsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerConfig_CredentialsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerConfig_CredentialsMultiError) AllErrors() []error { return m }

// ServerConfig_CredentialsValidationError is the validation error returned by
// ServerConfig_Credentials.Validate if the designated constraints aren't met.
type ServerConfig_CredentialsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerConfig_CredentialsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerConfig_CredentialsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerConfig_CredentialsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerConfig_CredentialsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerConfig_CredentialsValidationError) ErrorName() string {
	return "ServerConfig_CredentialsValidationError"
}

// Error satisfies the builtin error interface
func (e ServerConfig_CredentialsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerConfig_Credentials.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerConfig_CredentialsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerConfig_CredentialsValidationError{}

// Validate checks the field values on ServerConfig_Cluster_K3S with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServerConfig_Cluster_K3S) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerConfig_Cluster_K3S with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServerConfig_Cluster_K3SMultiError, or nil if none found.
func (m *ServerConfig_Cluster_K3S) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerConfig_Cluster_K3S) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ServerConfig_Cluster_K3SMultiError(errors)
	}

	return nil
}

// ServerConfig_Cluster_K3SMultiError is an error wrapping multiple validation
// errors returned by ServerConfig_Cluster_K3S.ValidateAll() if the designated
// constraints aren't met.
type ServerConfig_Cluster_K3SMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerConfig_Cluster_K3SMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerConfig_Cluster_K3SMultiError) AllErrors() []error { return m }

// ServerConfig_Cluster_K3SValidationError is the validation error returned by
// ServerConfig_Cluster_K3S.Validate if the designated constraints aren't met.
type ServerConfig_Cluster_K3SValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerConfig_Cluster_K3SValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerConfig_Cluster_K3SValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerConfig_Cluster_K3SValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerConfig_Cluster_K3SValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerConfig_Cluster_K3SValidationError) ErrorName() string {
	return "ServerConfig_Cluster_K3SValidationError"
}

// Error satisfies the builtin error interface
func (e ServerConfig_Cluster_K3SValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerConfig_Cluster_K3S.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerConfig_Cluster_K3SValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerConfig_Cluster_K3SValidationError{}

// Validate checks the field values on ServerConfig_Cluster_K3D with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServerConfig_Cluster_K3D) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerConfig_Cluster_K3D with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServerConfig_Cluster_K3DMultiError, or nil if none found.
func (m *ServerConfig_Cluster_K3D) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerConfig_Cluster_K3D) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetNodePortRanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerConfig_Cluster_K3DValidationError{
						field:  fmt.Sprintf("NodePortRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerConfig_Cluster_K3DValidationError{
						field:  fmt.Sprintf("NodePortRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerConfig_Cluster_K3DValidationError{
					field:  fmt.Sprintf("NodePortRanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServerConfig_Cluster_K3DMultiError(errors)
	}

	return nil
}

// ServerConfig_Cluster_K3DMultiError is an error wrapping multiple validation
// errors returned by ServerConfig_Cluster_K3D.ValidateAll() if the designated
// constraints aren't met.
type ServerConfig_Cluster_K3DMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerConfig_Cluster_K3DMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerConfig_Cluster_K3DMultiError) AllErrors() []error { return m }

// ServerConfig_Cluster_K3DValidationError is the validation error returned by
// ServerConfig_Cluster_K3D.Validate if the designated constraints aren't met.
type ServerConfig_Cluster_K3DValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerConfig_Cluster_K3DValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerConfig_Cluster_K3DValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerConfig_Cluster_K3DValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerConfig_Cluster_K3DValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerConfig_Cluster_K3DValidationError) ErrorName() string {
	return "ServerConfig_Cluster_K3DValidationError"
}

// Error satisfies the builtin error interface
func (e ServerConfig_Cluster_K3DValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerConfig_Cluster_K3D.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerConfig_Cluster_K3DValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerConfig_Cluster_K3DValidationError{}

// Validate checks the field values on ServerConfig_Cluster_K3D_NodePortRange
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ServerConfig_Cluster_K3D_NodePortRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ServerConfig_Cluster_K3D_NodePortRange with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ServerConfig_Cluster_K3D_NodePortRangeMultiError, or nil if none found.
func (m *ServerConfig_Cluster_K3D_NodePortRange) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerConfig_Cluster_K3D_NodePortRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetFromPort(); val < 30000 || val > 32767 {
		err := ServerConfig_Cluster_K3D_NodePortRangeValidationError{
			field:  "FromPort",
			reason: "value must be inside range [30000, 32767]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetToPort(); val < 30000 || val > 32767 {
		err := ServerConfig_Cluster_K3D_NodePortRangeValidationError{
			field:  "ToPort",
			reason: "value must be inside range [30000, 32767]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Host

	if _, ok := ServerConfig_Cluster_K3D_NodePortRange_Protocol_name[int32(m.GetProtocol())]; !ok {
		err := ServerConfig_Cluster_K3D_NodePortRangeValidationError{
			field:  "Protocol",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ServerConfig_Cluster_K3D_NodePortRangeMultiError(errors)
	}

	return nil
}

// ServerConfig_Cluster_K3D_NodePortRangeMultiError is an error wrapping
// multiple validation errors returned by
// ServerConfig_Cluster_K3D_NodePortRange.ValidateAll() if the designated
// constraints aren't met.
type ServerConfig_Cluster_K3D_NodePortRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerConfig_Cluster_K3D_NodePortRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerConfig_Cluster_K3D_NodePortRangeMultiError) AllErrors() []error { return m }

// ServerConfig_Cluster_K3D_NodePortRangeValidationError is the validation
// error returned by ServerConfig_Cluster_K3D_NodePortRange.Validate if the
// designated constraints aren't met.
type ServerConfig_Cluster_K3D_NodePortRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerConfig_Cluster_K3D_NodePortRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerConfig_Cluster_K3D_NodePortRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerConfig_Cluster_K3D_NodePortRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerConfig_Cluster_K3D_NodePortRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerConfig_Cluster_K3D_NodePortRangeValidationError) ErrorName() string {
	return "ServerConfig_Cluster_K3D_NodePortRangeValidationError"
}

// Error satisfies the builtin error interface
func (e ServerConfig_Cluster_K3D_NodePortRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerConfig_Cluster_K3D_NodePortRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerConfig_Cluster_K3D_NodePortRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerConfig_Cluster_K3D_NodePortRangeValidationError{}

// Validate checks the field values on ServerConfig_Image_ImagePullSecret with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ServerConfig_Image_ImagePullSecret) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerConfig_Image_ImagePullSecret
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ServerConfig_Image_ImagePullSecretMultiError, or nil if none found.
func (m *ServerConfig_Image_ImagePullSecret) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerConfig_Image_ImagePullSecret) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Server

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return ServerConfig_Image_ImagePullSecretMultiError(errors)
	}

	return nil
}

// ServerConfig_Image_ImagePullSecretMultiError is an error wrapping multiple
// validation errors returned by
// ServerConfig_Image_ImagePullSecret.ValidateAll() if the designated
// constraints aren't met.
type ServerConfig_Image_ImagePullSecretMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerConfig_Image_ImagePullSecretMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerConfig_Image_ImagePullSecretMultiError) AllErrors() []error { return m }

// ServerConfig_Image_ImagePullSecretValidationError is the validation error
// returned by ServerConfig_Image_ImagePullSecret.Validate if the designated
// constraints aren't met.
type ServerConfig_Image_ImagePullSecretValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerConfig_Image_ImagePullSecretValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerConfig_Image_ImagePullSecretValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerConfig_Image_ImagePullSecretValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerConfig_Image_ImagePullSecretValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerConfig_Image_ImagePullSecretValidationError) ErrorName() string {
	return "ServerConfig_Image_ImagePullSecretValidationError"
}

// Error satisfies the builtin error interface
func (e ServerConfig_Image_ImagePullSecretValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerConfig_Image_ImagePullSecret.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerConfig_Image_ImagePullSecretValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerConfig_Image_ImagePullSecretValidationError{}

// Validate checks the field values on ServerConfig_Credentials_Api with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServerConfig_Credentials_Api) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerConfig_Credentials_Api with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServerConfig_Credentials_ApiMultiError, or nil if none found.
func (m *ServerConfig_Credentials_Api) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerConfig_Credentials_Api) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetToken()) < 1 {
		err := ServerConfig_Credentials_ApiValidationError{
			field:  "Token",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ServerConfig_Credentials_ApiMultiError(errors)
	}

	return nil
}

// ServerConfig_Credentials_ApiMultiError is an error wrapping multiple
// validation errors returned by ServerConfig_Credentials_Api.ValidateAll() if
// the designated constraints aren't met.
type ServerConfig_Credentials_ApiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerConfig_Credentials_ApiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerConfig_Credentials_ApiMultiError) AllErrors() []error { return m }

// ServerConfig_Credentials_ApiValidationError is the validation error returned
// by ServerConfig_Credentials_Api.Validate if the designated constraints
// aren't met.
type ServerConfig_Credentials_ApiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerConfig_Credentials_ApiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerConfig_Credentials_ApiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerConfig_Credentials_ApiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerConfig_Credentials_ApiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerConfig_Credentials_ApiValidationError) ErrorName() string {
	return "ServerConfig_Credentials_ApiValidationError"
}

// Error satisfies the builtin error interface
func (e ServerConfig_Credentials_ApiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerConfig_Credentials_Api.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerConfig_Credentials_ApiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerConfig_Credentials_ApiValidationError{}

// Validate checks the field values on AdGuardConfig_BlockList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdGuardConfig_BlockList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdGuardConfig_BlockList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdGuardConfig_BlockListMultiError, or nil if none found.
func (m *AdGuardConfig_BlockList) ValidateAll() error {
	return m.validate(true)
}

func (m *AdGuardConfig_BlockList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() < 0 {
		err := AdGuardConfig_BlockListValidationError{
			field:  "Id",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := AdGuardConfig_BlockListValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetUrl()); err != nil {
		err = AdGuardConfig_BlockListValidationError{
			field:  "Url",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := AdGuardConfig_BlockListValidationError{
			field:  "Url",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Enabled

	if len(errors) > 0 {
		return AdGuardConfig_BlockListMultiError(errors)
	}

	return nil
}

// AdGuardConfig_BlockListMultiError is an error wrapping multiple validation
// errors returned by AdGuardConfig_BlockList.ValidateAll() if the designated
// constraints aren't met.
type AdGuardConfig_BlockListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdGuardConfig_BlockListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdGuardConfig_BlockListMultiError) AllErrors() []error { return m }

// AdGuardConfig_BlockListValidationError is the validation error returned by
// AdGuardConfig_BlockList.Validate if the designated constraints aren't met.
type AdGuardConfig_BlockListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdGuardConfig_BlockListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdGuardConfig_BlockListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdGuardConfig_BlockListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdGuardConfig_BlockListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdGuardConfig_BlockListValidationError) ErrorName() string {
	return "AdGuardConfig_BlockListValidationError"
}

// Error satisfies the builtin error interface
func (e AdGuardConfig_BlockListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdGuardConfig_BlockList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdGuardConfig_BlockListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdGuardConfig_BlockListValidationError{}

// Validate checks the field values on AdGuardConfig_Rule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdGuardConfig_Rule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdGuardConfig_Rule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdGuardConfig_RuleMultiError, or nil if none found.
func (m *AdGuardConfig_Rule) ValidateAll() error {
	return m.validate(true)
}

func (m *AdGuardConfig_Rule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRule()) < 1 {
		err := AdGuardConfig_RuleValidationError{
			field:  "Rule",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AdGuardConfig_RuleMultiError(errors)
	}

	return nil
}

// AdGuardConfig_RuleMultiError is an error wrapping multiple validation errors
// returned by AdGuardConfig_Rule.ValidateAll() if the designated constraints
// aren't met.
type AdGuardConfig_RuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdGuardConfig_RuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdGuardConfig_RuleMultiError) AllErrors() []error { return m }

// AdGuardConfig_RuleValidationError is the validation error returned by
// AdGuardConfig_Rule.Validate if the designated constraints aren't met.
type AdGuardConfig_RuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdGuardConfig_RuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdGuardConfig_RuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdGuardConfig_RuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdGuardConfig_RuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdGuardConfig_RuleValidationError) ErrorName() string {
	return "AdGuardConfig_RuleValidationError"
}

// Error satisfies the builtin error interface
func (e AdGuardConfig_RuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdGuardConfig_Rule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdGuardConfig_RuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdGuardConfig_RuleValidationError{}

// Validate checks the field values on AdGuardStatus_QueryLog with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdGuardStatus_QueryLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdGuardStatus_QueryLog with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdGuardStatus_QueryLogMultiError, or nil if none found.
func (m *AdGuardStatus_QueryLog) ValidateAll() error {
	return m.validate(true)
}

func (m *AdGuardStatus_QueryLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTimestamp() == nil {
		err := AdGuardStatus_QueryLogValidationError{
			field:  "Timestamp",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetRequest() == nil {
		err := AdGuardStatus_QueryLogValidationError{
			field:  "Request",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdGuardStatus_QueryLogValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdGuardStatus_QueryLogValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdGuardStatus_QueryLogValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetResponse() == nil {
		err := AdGuardStatus_QueryLogValidationError{
			field:  "Response",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdGuardStatus_QueryLogValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdGuardStatus_QueryLogValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdGuardStatus_QueryLogValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := AdGuardStatus_QueryLog_Reason_name[int32(m.GetReason())]; !ok {
		err := AdGuardStatus_QueryLogValidationError{
			field:  "Reason",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdGuardStatus_QueryLogValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdGuardStatus_QueryLogValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdGuardStatus_QueryLogValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetClient() == nil {
		err := AdGuardStatus_QueryLogValidationError{
			field:  "Client",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdGuardStatus_QueryLogValidationError{
					field:  "Client",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdGuardStatus_QueryLogValidationError{
					field:  "Client",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdGuardStatus_QueryLogValidationError{
				field:  "Client",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AdGuardStatus_QueryLogMultiError(errors)
	}

	return nil
}

// AdGuardStatus_QueryLogMultiError is an error wrapping multiple validation
// errors returned by AdGuardStatus_QueryLog.ValidateAll() if the designated
// constraints aren't met.
type AdGuardStatus_QueryLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdGuardStatus_QueryLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdGuardStatus_QueryLogMultiError) AllErrors() []error { return m }

// AdGuardStatus_QueryLogValidationError is the validation error returned by
// AdGuardStatus_QueryLog.Validate if the designated constraints aren't met.
type AdGuardStatus_QueryLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdGuardStatus_QueryLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdGuardStatus_QueryLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdGuardStatus_QueryLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdGuardStatus_QueryLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdGuardStatus_QueryLogValidationError) ErrorName() string {
	return "AdGuardStatus_QueryLogValidationError"
}

// Error satisfies the builtin error interface
func (e AdGuardStatus_QueryLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdGuardStatus_QueryLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdGuardStatus_QueryLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdGuardStatus_QueryLogValidationError{}

// Validate checks the field values on AdGuardStatus_QueryLog_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdGuardStatus_QueryLog_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdGuardStatus_QueryLog_Request with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AdGuardStatus_QueryLog_RequestMultiError, or nil if none found.
func (m *AdGuardStatus_QueryLog_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *AdGuardStatus_QueryLog_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClass()) < 1 {
		err := AdGuardStatus_QueryLog_RequestValidationError{
			field:  "Class",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := AdGuardStatus_QueryLog_RequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := AdGuardStatus_QueryLog_RequestValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AdGuardStatus_QueryLog_RequestMultiError(errors)
	}

	return nil
}

// AdGuardStatus_QueryLog_RequestMultiError is an error wrapping multiple
// validation errors returned by AdGuardStatus_QueryLog_Request.ValidateAll()
// if the designated constraints aren't met.
type AdGuardStatus_QueryLog_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdGuardStatus_QueryLog_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdGuardStatus_QueryLog_RequestMultiError) AllErrors() []error { return m }

// AdGuardStatus_QueryLog_RequestValidationError is the validation error
// returned by AdGuardStatus_QueryLog_Request.Validate if the designated
// constraints aren't met.
type AdGuardStatus_QueryLog_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdGuardStatus_QueryLog_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdGuardStatus_QueryLog_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdGuardStatus_QueryLog_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdGuardStatus_QueryLog_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdGuardStatus_QueryLog_RequestValidationError) ErrorName() string {
	return "AdGuardStatus_QueryLog_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e AdGuardStatus_QueryLog_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdGuardStatus_QueryLog_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdGuardStatus_QueryLog_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdGuardStatus_QueryLog_RequestValidationError{}

// Validate checks the field values on AdGuardStatus_QueryLog_Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdGuardStatus_QueryLog_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdGuardStatus_QueryLog_Response with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AdGuardStatus_QueryLog_ResponseMultiError, or nil if none found.
func (m *AdGuardStatus_QueryLog_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *AdGuardStatus_QueryLog_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetElapsedMs() < 0 {
		err := AdGuardStatus_QueryLog_ResponseValidationError{
			field:  "ElapsedMs",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetStatus()) < 1 {
		err := AdGuardStatus_QueryLog_ResponseValidationError{
			field:  "Status",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAnswers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdGuardStatus_QueryLog_ResponseValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdGuardStatus_QueryLog_ResponseValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdGuardStatus_QueryLog_ResponseValidationError{
					field:  fmt.Sprintf("Answers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AdGuardStatus_QueryLog_ResponseMultiError(errors)
	}

	return nil
}

// AdGuardStatus_QueryLog_ResponseMultiError is an error wrapping multiple
// validation errors returned by AdGuardStatus_QueryLog_Response.ValidateAll()
// if the designated constraints aren't met.
type AdGuardStatus_QueryLog_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdGuardStatus_QueryLog_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdGuardStatus_QueryLog_ResponseMultiError) AllErrors() []error { return m }

// AdGuardStatus_QueryLog_ResponseValidationError is the validation error
// returned by AdGuardStatus_QueryLog_Response.Validate if the designated
// constraints aren't met.
type AdGuardStatus_QueryLog_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdGuardStatus_QueryLog_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdGuardStatus_QueryLog_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdGuardStatus_QueryLog_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdGuardStatus_QueryLog_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdGuardStatus_QueryLog_ResponseValidationError) ErrorName() string {
	return "AdGuardStatus_QueryLog_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AdGuardStatus_QueryLog_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdGuardStatus_QueryLog_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdGuardStatus_QueryLog_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdGuardStatus_QueryLog_ResponseValidationError{}

// Validate checks the field values on AdGuardStatus_QueryLog_Rule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdGuardStatus_QueryLog_Rule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdGuardStatus_QueryLog_Rule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdGuardStatus_QueryLog_RuleMultiError, or nil if none found.
func (m *AdGuardStatus_QueryLog_Rule) ValidateAll() error {
	return m.validate(true)
}

func (m *AdGuardStatus_QueryLog_Rule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetFilterId() < 0 {
		err := AdGuardStatus_QueryLog_RuleValidationError{
			field:  "FilterId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetText()) < 1 {
		err := AdGuardStatus_QueryLog_RuleValidationError{
			field:  "Text",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AdGuardStatus_QueryLog_RuleMultiError(errors)
	}

	return nil
}

// AdGuardStatus_QueryLog_RuleMultiError is an error wrapping multiple
// validation errors returned by AdGuardStatus_QueryLog_Rule.ValidateAll() if
// the designated constraints aren't met.
type AdGuardStatus_QueryLog_RuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdGuardStatus_QueryLog_RuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdGuardStatus_QueryLog_RuleMultiError) AllErrors() []error { return m }

// AdGuardStatus_QueryLog_RuleValidationError is the validation error returned
// by AdGuardStatus_QueryLog_Rule.Validate if the designated constraints
// aren't met.
type AdGuardStatus_QueryLog_RuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdGuardStatus_QueryLog_RuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdGuardStatus_QueryLog_RuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdGuardStatus_QueryLog_RuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdGuardStatus_QueryLog_RuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdGuardStatus_QueryLog_RuleValidationError) ErrorName() string {
	return "AdGuardStatus_QueryLog_RuleValidationError"
}

// Error satisfies the builtin error interface
func (e AdGuardStatus_QueryLog_RuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdGuardStatus_QueryLog_Rule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdGuardStatus_QueryLog_RuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdGuardStatus_QueryLog_RuleValidationError{}

// Validate checks the field values on AdGuardStatus_QueryLog_Client with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdGuardStatus_QueryLog_Client) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdGuardStatus_QueryLog_Client with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AdGuardStatus_QueryLog_ClientMultiError, or nil if none found.
func (m *AdGuardStatus_QueryLog_Client) ValidateAll() error {
	return m.validate(true)
}

func (m *AdGuardStatus_QueryLog_Client) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) < 1 {
		err := AdGuardStatus_QueryLog_ClientValidationError{
			field:  "Address",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := AdGuardStatus_QueryLog_ClientValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AdGuardStatus_QueryLog_ClientMultiError(errors)
	}

	return nil
}

// AdGuardStatus_QueryLog_ClientMultiError is an error wrapping multiple
// validation errors returned by AdGuardStatus_QueryLog_Client.ValidateAll()
// if the designated constraints aren't met.
type AdGuardStatus_QueryLog_ClientMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdGuardStatus_QueryLog_ClientMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdGuardStatus_QueryLog_ClientMultiError) AllErrors() []error { return m }

// AdGuardStatus_QueryLog_ClientValidationError is the validation error
// returned by AdGuardStatus_QueryLog_Client.Validate if the designated
// constraints aren't met.
type AdGuardStatus_QueryLog_ClientValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdGuardStatus_QueryLog_ClientValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdGuardStatus_QueryLog_ClientValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdGuardStatus_QueryLog_ClientValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdGuardStatus_QueryLog_ClientValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdGuardStatus_QueryLog_ClientValidationError) ErrorName() string {
	return "AdGuardStatus_QueryLog_ClientValidationError"
}

// Error satisfies the builtin error interface
func (e AdGuardStatus_QueryLog_ClientValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdGuardStatus_QueryLog_Client.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdGuardStatus_QueryLog_ClientValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdGuardStatus_QueryLog_ClientValidationError{}

// Validate checks the field values on AdGuardStatus_QueryLog_Response_Answer
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *AdGuardStatus_QueryLog_Response_Answer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// AdGuardStatus_QueryLog_Response_Answer with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// AdGuardStatus_QueryLog_Response_AnswerMultiError, or nil if none found.
func (m *AdGuardStatus_QueryLog_Response_Answer) ValidateAll() error {
	return m.validate(true)
}

func (m *AdGuardStatus_QueryLog_Response_Answer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := AdGuardStatus_QueryLog_Response_AnswerValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetValue()) < 1 {
		err := AdGuardStatus_QueryLog_Response_AnswerValidationError{
			field:  "Value",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTtl() < 0 {
		err := AdGuardStatus_QueryLog_Response_AnswerValidationError{
			field:  "Ttl",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AdGuardStatus_QueryLog_Response_AnswerMultiError(errors)
	}

	return nil
}

// AdGuardStatus_QueryLog_Response_AnswerMultiError is an error wrapping
// multiple validation errors returned by
// AdGuardStatus_QueryLog_Response_Answer.ValidateAll() if the designated
// constraints aren't met.
type AdGuardStatus_QueryLog_Response_AnswerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdGuardStatus_QueryLog_Response_AnswerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdGuardStatus_QueryLog_Response_AnswerMultiError) AllErrors() []error { return m }

// AdGuardStatus_QueryLog_Response_AnswerValidationError is the validation
// error returned by AdGuardStatus_QueryLog_Response_Answer.Validate if the
// designated constraints aren't met.
type AdGuardStatus_QueryLog_Response_AnswerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdGuardStatus_QueryLog_Response_AnswerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdGuardStatus_QueryLog_Response_AnswerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdGuardStatus_QueryLog_Response_AnswerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdGuardStatus_QueryLog_Response_AnswerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdGuardStatus_QueryLog_Response_AnswerValidationError) ErrorName() string {
	return "AdGuardStatus_QueryLog_Response_AnswerValidationError"
}

// Error satisfies the builtin error interface
func (e AdGuardStatus_QueryLog_Response_AnswerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdGuardStatus_QueryLog_Response_Answer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdGuardStatus_QueryLog_Response_AnswerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdGuardStatus_QueryLog_Response_AnswerValidationError{}
